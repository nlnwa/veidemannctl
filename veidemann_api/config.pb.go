// Code generated by protoc-gen-go. DO NOT EDIT.
// source: config.proto

/*
Package veidemann_api is a generated protocol buffer package.

It is generated from these files:
	config.proto
	contentwriter.proto
	controller.proto
	dnsresolver.proto
	frontier.proto
	harvester.proto
	messages.proto
	report.proto
	robotsevaluator.proto
	status.proto

It has these top-level messages:
	Meta
	Label
	CrawlEntity
	Seed
	CrawlJob
	CrawlConfig
	CrawlScheduleConfig
	CrawlScope
	CrawlLimitsConfig
	BrowserConfig
	PolitenessConfig
	ExtraConfig
	BrowserScript
	CrawlHostGroupConfig
	LogLevels
	RoleMapping
	Data
	WriteRequestMeta
	WriteRequest
	WriteResponseMeta
	WriteReply
	GetRequest
	ListRequest
	CrawlEntityListReply
	SeedListRequest
	SeedListReply
	CrawlJobListReply
	CrawlConfigListReply
	CrawlScheduleConfigListReply
	PolitenessConfigListReply
	BrowserConfigListReply
	BrowserScriptListReply
	CrawlHostGroupConfigListReply
	RunCrawlRequest
	RunCrawlReply
	AbortCrawlRequest
	RoleList
	RoleMappingsListRequest
	RoleMappingsListReply
	OpenIdConnectIssuerReply
	ResolveRequest
	ResolveReply
	CrawlSeedRequest
	HarvestPageRequest
	HarvestPageReply
	CleanupExecutionRequest
	CrawlExecutionStatus
	CrawlLog
	PageLog
	CrawledContent
	ExtractedText
	CrawlHostGroup
	FetchError
	QueuedUri
	Cookie
	Screenshot
	Filter
	CrawlLogListRequest
	CrawlLogListReply
	PageLogListRequest
	PageLogListReply
	ScreenshotListRequest
	ScreenshotListReply
	IsAllowedRequest
	IsAllowedReply
	ExecutionsRequest
	ExecutionsListReply
	StatusDetail
*/
package veidemann_api

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/timestamp"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Role int32

const (
	// Any authenticated user
	Role_ANY_USER Role = 0
	// Any user including unauthenticated users
	Role_ANY Role = 1
	// Administrator
	Role_ADMIN Role = 2
	// Curator
	Role_CURATOR Role = 3
	// A user with permission to read internal data
	Role_READONLY Role = 4
)

var Role_name = map[int32]string{
	0: "ANY_USER",
	1: "ANY",
	2: "ADMIN",
	3: "CURATOR",
	4: "READONLY",
}
var Role_value = map[string]int32{
	"ANY_USER": 0,
	"ANY":      1,
	"ADMIN":    2,
	"CURATOR":  3,
	"READONLY": 4,
}

func (x Role) String() string {
	return proto.EnumName(Role_name, int32(x))
}
func (Role) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type PolitenessConfig_RobotsPolicy int32

const (
	PolitenessConfig_OBEY_ROBOTS   PolitenessConfig_RobotsPolicy = 0
	PolitenessConfig_IGNORE_ROBOTS PolitenessConfig_RobotsPolicy = 1
	PolitenessConfig_CUSTOM_ROBOTS PolitenessConfig_RobotsPolicy = 2
)

var PolitenessConfig_RobotsPolicy_name = map[int32]string{
	0: "OBEY_ROBOTS",
	1: "IGNORE_ROBOTS",
	2: "CUSTOM_ROBOTS",
}
var PolitenessConfig_RobotsPolicy_value = map[string]int32{
	"OBEY_ROBOTS":   0,
	"IGNORE_ROBOTS": 1,
	"CUSTOM_ROBOTS": 2,
}

func (x PolitenessConfig_RobotsPolicy) String() string {
	return proto.EnumName(PolitenessConfig_RobotsPolicy_name, int32(x))
}
func (PolitenessConfig_RobotsPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{10, 0}
}

type LogLevels_Level int32

const (
	LogLevels_UNDEFINED LogLevels_Level = 0
	LogLevels_ALL       LogLevels_Level = 1
	LogLevels_TRACE     LogLevels_Level = 2
	LogLevels_DEBUG     LogLevels_Level = 3
	LogLevels_INFO      LogLevels_Level = 4
	LogLevels_WARN      LogLevels_Level = 5
	LogLevels_ERROR     LogLevels_Level = 6
	LogLevels_FATAL     LogLevels_Level = 7
	LogLevels_OFF       LogLevels_Level = 8
)

var LogLevels_Level_name = map[int32]string{
	0: "UNDEFINED",
	1: "ALL",
	2: "TRACE",
	3: "DEBUG",
	4: "INFO",
	5: "WARN",
	6: "ERROR",
	7: "FATAL",
	8: "OFF",
}
var LogLevels_Level_value = map[string]int32{
	"UNDEFINED": 0,
	"ALL":       1,
	"TRACE":     2,
	"DEBUG":     3,
	"INFO":      4,
	"WARN":      5,
	"ERROR":     6,
	"FATAL":     7,
	"OFF":       8,
}

func (x LogLevels_Level) String() string {
	return proto.EnumName(LogLevels_Level_name, int32(x))
}
func (LogLevels_Level) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{14, 0} }

type Meta struct {
	Name           string                     `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Description    string                     `protobuf:"bytes,2,opt,name=description" json:"description,omitempty"`
	Created        *google_protobuf.Timestamp `protobuf:"bytes,3,opt,name=created" json:"created,omitempty"`
	CreatedBy      string                     `protobuf:"bytes,4,opt,name=created_by,json=createdBy" json:"created_by,omitempty"`
	LastModified   *google_protobuf.Timestamp `protobuf:"bytes,5,opt,name=last_modified,json=lastModified" json:"last_modified,omitempty"`
	LastModifiedBy string                     `protobuf:"bytes,6,opt,name=last_modified_by,json=lastModifiedBy" json:"last_modified_by,omitempty"`
	Label          []*Label                   `protobuf:"bytes,7,rep,name=label" json:"label,omitempty"`
}

func (m *Meta) Reset()                    { *m = Meta{} }
func (m *Meta) String() string            { return proto.CompactTextString(m) }
func (*Meta) ProtoMessage()               {}
func (*Meta) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Meta) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Meta) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Meta) GetCreated() *google_protobuf.Timestamp {
	if m != nil {
		return m.Created
	}
	return nil
}

func (m *Meta) GetCreatedBy() string {
	if m != nil {
		return m.CreatedBy
	}
	return ""
}

func (m *Meta) GetLastModified() *google_protobuf.Timestamp {
	if m != nil {
		return m.LastModified
	}
	return nil
}

func (m *Meta) GetLastModifiedBy() string {
	if m != nil {
		return m.LastModifiedBy
	}
	return ""
}

func (m *Meta) GetLabel() []*Label {
	if m != nil {
		return m.Label
	}
	return nil
}

type Label struct {
	Key   string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *Label) Reset()                    { *m = Label{} }
func (m *Label) String() string            { return proto.CompactTextString(m) }
func (*Label) ProtoMessage()               {}
func (*Label) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Label) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Label) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// A crawl entity (might be an organisation with one or more seeds)
type CrawlEntity struct {
	Id   string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Meta *Meta  `protobuf:"bytes,2,opt,name=meta" json:"meta,omitempty"`
}

func (m *CrawlEntity) Reset()                    { *m = CrawlEntity{} }
func (m *CrawlEntity) String() string            { return proto.CompactTextString(m) }
func (*CrawlEntity) ProtoMessage()               {}
func (*CrawlEntity) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *CrawlEntity) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CrawlEntity) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

type Seed struct {
	Id       string      `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Meta     *Meta       `protobuf:"bytes,2,opt,name=meta" json:"meta,omitempty"`
	EntityId string      `protobuf:"bytes,3,opt,name=entity_id,json=entityId" json:"entity_id,omitempty"`
	Scope    *CrawlScope `protobuf:"bytes,4,opt,name=scope" json:"scope,omitempty"`
	JobId    []string    `protobuf:"bytes,5,rep,name=job_id,json=jobId" json:"job_id,omitempty"`
	Disabled bool        `protobuf:"varint,18,opt,name=disabled" json:"disabled,omitempty"`
}

func (m *Seed) Reset()                    { *m = Seed{} }
func (m *Seed) String() string            { return proto.CompactTextString(m) }
func (*Seed) ProtoMessage()               {}
func (*Seed) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Seed) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Seed) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *Seed) GetEntityId() string {
	if m != nil {
		return m.EntityId
	}
	return ""
}

func (m *Seed) GetScope() *CrawlScope {
	if m != nil {
		return m.Scope
	}
	return nil
}

func (m *Seed) GetJobId() []string {
	if m != nil {
		return m.JobId
	}
	return nil
}

func (m *Seed) GetDisabled() bool {
	if m != nil {
		return m.Disabled
	}
	return false
}

type CrawlJob struct {
	Id            string             `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Meta          *Meta              `protobuf:"bytes,2,opt,name=meta" json:"meta,omitempty"`
	ScheduleId    string             `protobuf:"bytes,3,opt,name=schedule_id,json=scheduleId" json:"schedule_id,omitempty"`
	Limits        *CrawlLimitsConfig `protobuf:"bytes,4,opt,name=limits" json:"limits,omitempty"`
	CrawlConfigId string             `protobuf:"bytes,5,opt,name=crawl_config_id,json=crawlConfigId" json:"crawl_config_id,omitempty"`
	Disabled      bool               `protobuf:"varint,18,opt,name=disabled" json:"disabled,omitempty"`
}

func (m *CrawlJob) Reset()                    { *m = CrawlJob{} }
func (m *CrawlJob) String() string            { return proto.CompactTextString(m) }
func (*CrawlJob) ProtoMessage()               {}
func (*CrawlJob) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *CrawlJob) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CrawlJob) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *CrawlJob) GetScheduleId() string {
	if m != nil {
		return m.ScheduleId
	}
	return ""
}

func (m *CrawlJob) GetLimits() *CrawlLimitsConfig {
	if m != nil {
		return m.Limits
	}
	return nil
}

func (m *CrawlJob) GetCrawlConfigId() string {
	if m != nil {
		return m.CrawlConfigId
	}
	return ""
}

func (m *CrawlJob) GetDisabled() bool {
	if m != nil {
		return m.Disabled
	}
	return false
}

type CrawlConfig struct {
	Id              string       `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Meta            *Meta        `protobuf:"bytes,2,opt,name=meta" json:"meta,omitempty"`
	BrowserConfigId string       `protobuf:"bytes,7,opt,name=browser_config_id,json=browserConfigId" json:"browser_config_id,omitempty"`
	PolitenessId    string       `protobuf:"bytes,8,opt,name=politeness_id,json=politenessId" json:"politeness_id,omitempty"`
	Extra           *ExtraConfig `protobuf:"bytes,9,opt,name=extra" json:"extra,omitempty"`
	MinimumDnsTtlS  int32        `protobuf:"varint,10,opt,name=minimum_dns_ttl_s,json=minimumDnsTtlS" json:"minimum_dns_ttl_s,omitempty"`
	DepthFirst      bool         `protobuf:"varint,20,opt,name=depth_first,json=depthFirst" json:"depth_first,omitempty"`
}

func (m *CrawlConfig) Reset()                    { *m = CrawlConfig{} }
func (m *CrawlConfig) String() string            { return proto.CompactTextString(m) }
func (*CrawlConfig) ProtoMessage()               {}
func (*CrawlConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *CrawlConfig) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CrawlConfig) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *CrawlConfig) GetBrowserConfigId() string {
	if m != nil {
		return m.BrowserConfigId
	}
	return ""
}

func (m *CrawlConfig) GetPolitenessId() string {
	if m != nil {
		return m.PolitenessId
	}
	return ""
}

func (m *CrawlConfig) GetExtra() *ExtraConfig {
	if m != nil {
		return m.Extra
	}
	return nil
}

func (m *CrawlConfig) GetMinimumDnsTtlS() int32 {
	if m != nil {
		return m.MinimumDnsTtlS
	}
	return 0
}

func (m *CrawlConfig) GetDepthFirst() bool {
	if m != nil {
		return m.DepthFirst
	}
	return false
}

type CrawlScheduleConfig struct {
	Id             string                     `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Meta           *Meta                      `protobuf:"bytes,2,opt,name=meta" json:"meta,omitempty"`
	CronExpression string                     `protobuf:"bytes,3,opt,name=cron_expression,json=cronExpression" json:"cron_expression,omitempty"`
	ValidFrom      *google_protobuf.Timestamp `protobuf:"bytes,4,opt,name=valid_from,json=validFrom" json:"valid_from,omitempty"`
	ValidTo        *google_protobuf.Timestamp `protobuf:"bytes,5,opt,name=valid_to,json=validTo" json:"valid_to,omitempty"`
}

func (m *CrawlScheduleConfig) Reset()                    { *m = CrawlScheduleConfig{} }
func (m *CrawlScheduleConfig) String() string            { return proto.CompactTextString(m) }
func (*CrawlScheduleConfig) ProtoMessage()               {}
func (*CrawlScheduleConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *CrawlScheduleConfig) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CrawlScheduleConfig) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *CrawlScheduleConfig) GetCronExpression() string {
	if m != nil {
		return m.CronExpression
	}
	return ""
}

func (m *CrawlScheduleConfig) GetValidFrom() *google_protobuf.Timestamp {
	if m != nil {
		return m.ValidFrom
	}
	return nil
}

func (m *CrawlScheduleConfig) GetValidTo() *google_protobuf.Timestamp {
	if m != nil {
		return m.ValidTo
	}
	return nil
}

type CrawlScope struct {
	SurtPrefix string `protobuf:"bytes,1,opt,name=surt_prefix,json=surtPrefix" json:"surt_prefix,omitempty"`
}

func (m *CrawlScope) Reset()                    { *m = CrawlScope{} }
func (m *CrawlScope) String() string            { return proto.CompactTextString(m) }
func (*CrawlScope) ProtoMessage()               {}
func (*CrawlScope) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *CrawlScope) GetSurtPrefix() string {
	if m != nil {
		return m.SurtPrefix
	}
	return ""
}

type CrawlLimitsConfig struct {
	// How deep from a seed to crawl
	Depth int32 `protobuf:"varint,1,opt,name=depth" json:"depth,omitempty"`
	// Maximum time in seconds allowed for crawl to finish
	MaxDurationS int64 `protobuf:"varint,2,opt,name=max_duration_s,json=maxDurationS" json:"max_duration_s,omitempty"`
	// Maximum number of bytes to fetch before ending crawl
	MaxBytes int64 `protobuf:"varint,3,opt,name=max_bytes,json=maxBytes" json:"max_bytes,omitempty"`
}

func (m *CrawlLimitsConfig) Reset()                    { *m = CrawlLimitsConfig{} }
func (m *CrawlLimitsConfig) String() string            { return proto.CompactTextString(m) }
func (*CrawlLimitsConfig) ProtoMessage()               {}
func (*CrawlLimitsConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *CrawlLimitsConfig) GetDepth() int32 {
	if m != nil {
		return m.Depth
	}
	return 0
}

func (m *CrawlLimitsConfig) GetMaxDurationS() int64 {
	if m != nil {
		return m.MaxDurationS
	}
	return 0
}

func (m *CrawlLimitsConfig) GetMaxBytes() int64 {
	if m != nil {
		return m.MaxBytes
	}
	return 0
}

type BrowserConfig struct {
	Id                string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Meta              *Meta  `protobuf:"bytes,2,opt,name=meta" json:"meta,omitempty"`
	UserAgent         string `protobuf:"bytes,3,opt,name=user_agent,json=userAgent" json:"user_agent,omitempty"`
	WindowWidth       int32  `protobuf:"varint,4,opt,name=window_width,json=windowWidth" json:"window_width,omitempty"`
	WindowHeight      int32  `protobuf:"varint,5,opt,name=window_height,json=windowHeight" json:"window_height,omitempty"`
	PageLoadTimeoutMs int64  `protobuf:"varint,6,opt,name=page_load_timeout_ms,json=pageLoadTimeoutMs" json:"page_load_timeout_ms,omitempty"`
	// Select scripts by label
	// A string representing a label query. The query matches if at least one label matches the query.
	// If there are multiple queries, then each query must match at least one label.
	// Label quries are case insensitive. The basic format is <code>key:value</code> where both key and value must match.
	// If value ends with <code>&ast;</code> then the key must match and value must match up until the <code>&ast;</code>.
	// If value is empty, all labels matching the key will match.
	// If key is empty, then the matching is done on the value for all keys.
	// If key is empty, then the <code>:</code> might be ommitted.
	// <pre>
	// Examples:
	//   "foo:bar"  - matches exactly labels with key=foo and value=bar
	//   "foo:"     - matches all labels with key=foo
	//   ":bar"     - matches all labels with value=bar
	//   "bar"      - matches all labels with value=bar
	//   "foo:ba*"  - matches labels with key=foo and value starting with ba (e.g. matches bar, but not ber)
	//   ":ba*"     - matches labels with any key and value starting with ba (e.g. matches bar, but not ber)
	//   "ba*"      - matches labels with any key and value starting with ba (e.g. matches bar, but not ber)
	//   ":"        - matches every label
	//   ""         - matches every label
	// </pre>
	ScriptSelector       []string          `protobuf:"bytes,7,rep,name=script_selector,json=scriptSelector" json:"script_selector,omitempty"`
	ScriptId             []string          `protobuf:"bytes,8,rep,name=script_id,json=scriptId" json:"script_id,omitempty"`
	Headers              map[string]string `protobuf:"bytes,16,rep,name=headers" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	ScriptParameters     map[string]string `protobuf:"bytes,17,rep,name=script_parameters,json=scriptParameters" json:"script_parameters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	SleepAfterPageloadMs int64             `protobuf:"varint,18,opt,name=sleep_after_pageload_ms,json=sleepAfterPageloadMs" json:"sleep_after_pageload_ms,omitempty"`
}

func (m *BrowserConfig) Reset()                    { *m = BrowserConfig{} }
func (m *BrowserConfig) String() string            { return proto.CompactTextString(m) }
func (*BrowserConfig) ProtoMessage()               {}
func (*BrowserConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *BrowserConfig) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *BrowserConfig) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *BrowserConfig) GetUserAgent() string {
	if m != nil {
		return m.UserAgent
	}
	return ""
}

func (m *BrowserConfig) GetWindowWidth() int32 {
	if m != nil {
		return m.WindowWidth
	}
	return 0
}

func (m *BrowserConfig) GetWindowHeight() int32 {
	if m != nil {
		return m.WindowHeight
	}
	return 0
}

func (m *BrowserConfig) GetPageLoadTimeoutMs() int64 {
	if m != nil {
		return m.PageLoadTimeoutMs
	}
	return 0
}

func (m *BrowserConfig) GetScriptSelector() []string {
	if m != nil {
		return m.ScriptSelector
	}
	return nil
}

func (m *BrowserConfig) GetScriptId() []string {
	if m != nil {
		return m.ScriptId
	}
	return nil
}

func (m *BrowserConfig) GetHeaders() map[string]string {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *BrowserConfig) GetScriptParameters() map[string]string {
	if m != nil {
		return m.ScriptParameters
	}
	return nil
}

func (m *BrowserConfig) GetSleepAfterPageloadMs() int64 {
	if m != nil {
		return m.SleepAfterPageloadMs
	}
	return 0
}

type PolitenessConfig struct {
	Id                             string                        `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Meta                           *Meta                         `protobuf:"bytes,2,opt,name=meta" json:"meta,omitempty"`
	RobotsPolicy                   PolitenessConfig_RobotsPolicy `protobuf:"varint,3,opt,name=robots_policy,json=robotsPolicy,enum=veidemann.api.PolitenessConfig_RobotsPolicy" json:"robots_policy,omitempty"`
	MinimumRobotsValidityDurationS int32                         `protobuf:"varint,11,opt,name=minimum_robots_validity_duration_s,json=minimumRobotsValidityDurationS" json:"minimum_robots_validity_duration_s,omitempty"`
	CustomRobots                   string                        `protobuf:"bytes,20,opt,name=custom_robots,json=customRobots" json:"custom_robots,omitempty"`
	MinTimeBetweenPageLoadMs       int64                         `protobuf:"varint,4,opt,name=min_time_between_page_load_ms,json=minTimeBetweenPageLoadMs" json:"min_time_between_page_load_ms,omitempty"`
	MaxTimeBetweenPageLoadMs       int64                         `protobuf:"varint,5,opt,name=max_time_between_page_load_ms,json=maxTimeBetweenPageLoadMs" json:"max_time_between_page_load_ms,omitempty"`
	// *
	// The fetch time of the URI is multiplied with this value to get the delay time before fetching the next URI.
	// If min_time_between_page_load_ms and/or max_time_between_page_load_ms are set, then those values are used as
	// the upper/lower limits for delay.
	// If delay_factor is unset or zero, then a delay_facor of one is assumed. If delay_factor is negative,
	// a delay_factor of zero is assumed.
	DelayFactor       float32 `protobuf:"fixed32,6,opt,name=delay_factor,json=delayFactor" json:"delay_factor,omitempty"`
	MaxRetries        int32   `protobuf:"varint,7,opt,name=max_retries,json=maxRetries" json:"max_retries,omitempty"`
	RetryDelaySeconds int32   `protobuf:"varint,8,opt,name=retry_delay_seconds,json=retryDelaySeconds" json:"retry_delay_seconds,omitempty"`
	// Select crawl host groups by label
	// A string representing a label query. The query matches if at least one label matches the query.
	// If there are multiple queries, then each query must match at least one label.
	// Label quries are case insensitive. The basic format is <code>key:value</code> where both key and value must match.
	// If value ends with <code>&ast;</code> then the key must match and value must match up until the <code>&ast;</code>.
	// If value is empty, all labels matching the key will match.
	// If key is empty, then the matching is done on the value for all keys.
	// If key is empty, then the <code>:</code> might be ommitted.
	// <pre>
	// Examples:
	//   "foo:bar"  - matches exactly labels with key=foo and value=bar
	//   "foo:"     - matches all labels with key=foo
	//   ":bar"     - matches all labels with value=bar
	//   "bar"      - matches all labels with value=bar
	//   "foo:ba*"  - matches labels with key=foo and value starting with ba (e.g. matches bar, but not ber)
	//   ":ba*"     - matches labels with any key and value starting with ba (e.g. matches bar, but not ber)
	//   "ba*"      - matches labels with any key and value starting with ba (e.g. matches bar, but not ber)
	//   ":"        - matches every label
	//   ""         - matches every label
	// </pre>
	CrawlHostGroupSelector []string `protobuf:"bytes,9,rep,name=crawl_host_group_selector,json=crawlHostGroupSelector" json:"crawl_host_group_selector,omitempty"`
}

func (m *PolitenessConfig) Reset()                    { *m = PolitenessConfig{} }
func (m *PolitenessConfig) String() string            { return proto.CompactTextString(m) }
func (*PolitenessConfig) ProtoMessage()               {}
func (*PolitenessConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *PolitenessConfig) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *PolitenessConfig) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *PolitenessConfig) GetRobotsPolicy() PolitenessConfig_RobotsPolicy {
	if m != nil {
		return m.RobotsPolicy
	}
	return PolitenessConfig_OBEY_ROBOTS
}

func (m *PolitenessConfig) GetMinimumRobotsValidityDurationS() int32 {
	if m != nil {
		return m.MinimumRobotsValidityDurationS
	}
	return 0
}

func (m *PolitenessConfig) GetCustomRobots() string {
	if m != nil {
		return m.CustomRobots
	}
	return ""
}

func (m *PolitenessConfig) GetMinTimeBetweenPageLoadMs() int64 {
	if m != nil {
		return m.MinTimeBetweenPageLoadMs
	}
	return 0
}

func (m *PolitenessConfig) GetMaxTimeBetweenPageLoadMs() int64 {
	if m != nil {
		return m.MaxTimeBetweenPageLoadMs
	}
	return 0
}

func (m *PolitenessConfig) GetDelayFactor() float32 {
	if m != nil {
		return m.DelayFactor
	}
	return 0
}

func (m *PolitenessConfig) GetMaxRetries() int32 {
	if m != nil {
		return m.MaxRetries
	}
	return 0
}

func (m *PolitenessConfig) GetRetryDelaySeconds() int32 {
	if m != nil {
		return m.RetryDelaySeconds
	}
	return 0
}

func (m *PolitenessConfig) GetCrawlHostGroupSelector() []string {
	if m != nil {
		return m.CrawlHostGroupSelector
	}
	return nil
}

type ExtraConfig struct {
	ExtractText    bool `protobuf:"varint,5,opt,name=extract_text,json=extractText" json:"extract_text,omitempty"`
	CreateSnapshot bool `protobuf:"varint,6,opt,name=create_snapshot,json=createSnapshot" json:"create_snapshot,omitempty"`
}

func (m *ExtraConfig) Reset()                    { *m = ExtraConfig{} }
func (m *ExtraConfig) String() string            { return proto.CompactTextString(m) }
func (*ExtraConfig) ProtoMessage()               {}
func (*ExtraConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *ExtraConfig) GetExtractText() bool {
	if m != nil {
		return m.ExtractText
	}
	return false
}

func (m *ExtraConfig) GetCreateSnapshot() bool {
	if m != nil {
		return m.CreateSnapshot
	}
	return false
}

// Message containing a javascript to be run in a browser
type BrowserScript struct {
	Id        string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Meta      *Meta  `protobuf:"bytes,2,opt,name=meta" json:"meta,omitempty"`
	Script    string `protobuf:"bytes,3,opt,name=script" json:"script,omitempty"`
	UrlRegexp string `protobuf:"bytes,4,opt,name=url_regexp,json=urlRegexp" json:"url_regexp,omitempty"`
}

func (m *BrowserScript) Reset()                    { *m = BrowserScript{} }
func (m *BrowserScript) String() string            { return proto.CompactTextString(m) }
func (*BrowserScript) ProtoMessage()               {}
func (*BrowserScript) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *BrowserScript) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *BrowserScript) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *BrowserScript) GetScript() string {
	if m != nil {
		return m.Script
	}
	return ""
}

func (m *BrowserScript) GetUrlRegexp() string {
	if m != nil {
		return m.UrlRegexp
	}
	return ""
}

type CrawlHostGroupConfig struct {
	Id      string                          `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Meta    *Meta                           `protobuf:"bytes,2,opt,name=meta" json:"meta,omitempty"`
	IpRange []*CrawlHostGroupConfig_IpRange `protobuf:"bytes,3,rep,name=ip_range,json=ipRange" json:"ip_range,omitempty"`
}

func (m *CrawlHostGroupConfig) Reset()                    { *m = CrawlHostGroupConfig{} }
func (m *CrawlHostGroupConfig) String() string            { return proto.CompactTextString(m) }
func (*CrawlHostGroupConfig) ProtoMessage()               {}
func (*CrawlHostGroupConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *CrawlHostGroupConfig) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CrawlHostGroupConfig) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *CrawlHostGroupConfig) GetIpRange() []*CrawlHostGroupConfig_IpRange {
	if m != nil {
		return m.IpRange
	}
	return nil
}

type CrawlHostGroupConfig_IpRange struct {
	IpFrom string `protobuf:"bytes,1,opt,name=ip_from,json=ipFrom" json:"ip_from,omitempty"`
	IpTo   string `protobuf:"bytes,2,opt,name=ip_to,json=ipTo" json:"ip_to,omitempty"`
}

func (m *CrawlHostGroupConfig_IpRange) Reset()         { *m = CrawlHostGroupConfig_IpRange{} }
func (m *CrawlHostGroupConfig_IpRange) String() string { return proto.CompactTextString(m) }
func (*CrawlHostGroupConfig_IpRange) ProtoMessage()    {}
func (*CrawlHostGroupConfig_IpRange) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{13, 0}
}

func (m *CrawlHostGroupConfig_IpRange) GetIpFrom() string {
	if m != nil {
		return m.IpFrom
	}
	return ""
}

func (m *CrawlHostGroupConfig_IpRange) GetIpTo() string {
	if m != nil {
		return m.IpTo
	}
	return ""
}

type LogLevels struct {
	LogLevel []*LogLevels_LogLevel `protobuf:"bytes,1,rep,name=log_level,json=logLevel" json:"log_level,omitempty"`
}

func (m *LogLevels) Reset()                    { *m = LogLevels{} }
func (m *LogLevels) String() string            { return proto.CompactTextString(m) }
func (*LogLevels) ProtoMessage()               {}
func (*LogLevels) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *LogLevels) GetLogLevel() []*LogLevels_LogLevel {
	if m != nil {
		return m.LogLevel
	}
	return nil
}

type LogLevels_LogLevel struct {
	Logger string          `protobuf:"bytes,1,opt,name=logger" json:"logger,omitempty"`
	Level  LogLevels_Level `protobuf:"varint,2,opt,name=level,enum=veidemann.api.LogLevels_Level" json:"level,omitempty"`
}

func (m *LogLevels_LogLevel) Reset()                    { *m = LogLevels_LogLevel{} }
func (m *LogLevels_LogLevel) String() string            { return proto.CompactTextString(m) }
func (*LogLevels_LogLevel) ProtoMessage()               {}
func (*LogLevels_LogLevel) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14, 0} }

func (m *LogLevels_LogLevel) GetLogger() string {
	if m != nil {
		return m.Logger
	}
	return ""
}

func (m *LogLevels_LogLevel) GetLevel() LogLevels_Level {
	if m != nil {
		return m.Level
	}
	return LogLevels_UNDEFINED
}

type RoleMapping struct {
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// Types that are valid to be assigned to EmailOrGroup:
	//	*RoleMapping_Email
	//	*RoleMapping_Group
	EmailOrGroup isRoleMapping_EmailOrGroup `protobuf_oneof:"email_or_group"`
	Role         []Role                     `protobuf:"varint,4,rep,packed,name=role,enum=veidemann.api.Role" json:"role,omitempty"`
}

func (m *RoleMapping) Reset()                    { *m = RoleMapping{} }
func (m *RoleMapping) String() string            { return proto.CompactTextString(m) }
func (*RoleMapping) ProtoMessage()               {}
func (*RoleMapping) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

type isRoleMapping_EmailOrGroup interface {
	isRoleMapping_EmailOrGroup()
}

type RoleMapping_Email struct {
	Email string `protobuf:"bytes,2,opt,name=email,oneof"`
}
type RoleMapping_Group struct {
	Group string `protobuf:"bytes,3,opt,name=group,oneof"`
}

func (*RoleMapping_Email) isRoleMapping_EmailOrGroup() {}
func (*RoleMapping_Group) isRoleMapping_EmailOrGroup() {}

func (m *RoleMapping) GetEmailOrGroup() isRoleMapping_EmailOrGroup {
	if m != nil {
		return m.EmailOrGroup
	}
	return nil
}

func (m *RoleMapping) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *RoleMapping) GetEmail() string {
	if x, ok := m.GetEmailOrGroup().(*RoleMapping_Email); ok {
		return x.Email
	}
	return ""
}

func (m *RoleMapping) GetGroup() string {
	if x, ok := m.GetEmailOrGroup().(*RoleMapping_Group); ok {
		return x.Group
	}
	return ""
}

func (m *RoleMapping) GetRole() []Role {
	if m != nil {
		return m.Role
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RoleMapping) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RoleMapping_OneofMarshaler, _RoleMapping_OneofUnmarshaler, _RoleMapping_OneofSizer, []interface{}{
		(*RoleMapping_Email)(nil),
		(*RoleMapping_Group)(nil),
	}
}

func _RoleMapping_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RoleMapping)
	// email_or_group
	switch x := m.EmailOrGroup.(type) {
	case *RoleMapping_Email:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Email)
	case *RoleMapping_Group:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Group)
	case nil:
	default:
		return fmt.Errorf("RoleMapping.EmailOrGroup has unexpected type %T", x)
	}
	return nil
}

func _RoleMapping_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RoleMapping)
	switch tag {
	case 2: // email_or_group.email
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.EmailOrGroup = &RoleMapping_Email{x}
		return true, err
	case 3: // email_or_group.group
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.EmailOrGroup = &RoleMapping_Group{x}
		return true, err
	default:
		return false, nil
	}
}

func _RoleMapping_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RoleMapping)
	// email_or_group
	switch x := m.EmailOrGroup.(type) {
	case *RoleMapping_Email:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Email)))
		n += len(x.Email)
	case *RoleMapping_Group:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Group)))
		n += len(x.Group)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*Meta)(nil), "veidemann.api.Meta")
	proto.RegisterType((*Label)(nil), "veidemann.api.Label")
	proto.RegisterType((*CrawlEntity)(nil), "veidemann.api.CrawlEntity")
	proto.RegisterType((*Seed)(nil), "veidemann.api.Seed")
	proto.RegisterType((*CrawlJob)(nil), "veidemann.api.CrawlJob")
	proto.RegisterType((*CrawlConfig)(nil), "veidemann.api.CrawlConfig")
	proto.RegisterType((*CrawlScheduleConfig)(nil), "veidemann.api.CrawlScheduleConfig")
	proto.RegisterType((*CrawlScope)(nil), "veidemann.api.CrawlScope")
	proto.RegisterType((*CrawlLimitsConfig)(nil), "veidemann.api.CrawlLimitsConfig")
	proto.RegisterType((*BrowserConfig)(nil), "veidemann.api.BrowserConfig")
	proto.RegisterType((*PolitenessConfig)(nil), "veidemann.api.PolitenessConfig")
	proto.RegisterType((*ExtraConfig)(nil), "veidemann.api.ExtraConfig")
	proto.RegisterType((*BrowserScript)(nil), "veidemann.api.BrowserScript")
	proto.RegisterType((*CrawlHostGroupConfig)(nil), "veidemann.api.CrawlHostGroupConfig")
	proto.RegisterType((*CrawlHostGroupConfig_IpRange)(nil), "veidemann.api.CrawlHostGroupConfig.IpRange")
	proto.RegisterType((*LogLevels)(nil), "veidemann.api.LogLevels")
	proto.RegisterType((*LogLevels_LogLevel)(nil), "veidemann.api.LogLevels.LogLevel")
	proto.RegisterType((*RoleMapping)(nil), "veidemann.api.RoleMapping")
	proto.RegisterEnum("veidemann.api.Role", Role_name, Role_value)
	proto.RegisterEnum("veidemann.api.PolitenessConfig_RobotsPolicy", PolitenessConfig_RobotsPolicy_name, PolitenessConfig_RobotsPolicy_value)
	proto.RegisterEnum("veidemann.api.LogLevels_Level", LogLevels_Level_name, LogLevels_Level_value)
}

func init() { proto.RegisterFile("config.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1665 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x57, 0xdd, 0x72, 0x1b, 0xb7,
	0x15, 0x36, 0x7f, 0x56, 0x24, 0x0f, 0x29, 0x79, 0x05, 0x2b, 0x36, 0xa3, 0x8e, 0x13, 0x79, 0xd3,
	0x69, 0x14, 0xb7, 0xa5, 0x3a, 0x6a, 0x3c, 0x4d, 0x72, 0xd1, 0x0c, 0x49, 0x91, 0x36, 0x33, 0x14,
	0xa9, 0x82, 0x54, 0x53, 0xf5, 0x06, 0x03, 0x72, 0x21, 0x12, 0xe9, 0xee, 0x62, 0x67, 0x01, 0x5a,
	0xe4, 0x55, 0x6f, 0x3a, 0xd3, 0xde, 0xf5, 0xaa, 0xef, 0xd0, 0xc7, 0xe8, 0x23, 0xf4, 0x19, 0x7a,
	0xd7, 0xb7, 0xe8, 0xe0, 0x87, 0x12, 0x25, 0xbb, 0x4e, 0x22, 0xdf, 0x01, 0xdf, 0xf9, 0xf0, 0x01,
	0x38, 0x38, 0x3f, 0xbb, 0x50, 0x9b, 0x8a, 0xe4, 0x92, 0xcf, 0x1a, 0x69, 0x26, 0x94, 0x40, 0xdb,
	0xaf, 0x19, 0x0f, 0x59, 0x4c, 0x93, 0xa4, 0x41, 0x53, 0xbe, 0xff, 0xf1, 0x4c, 0x88, 0x59, 0xc4,
	0x8e, 0x8c, 0x71, 0xb2, 0xb8, 0x3c, 0x52, 0x3c, 0x66, 0x52, 0xd1, 0x38, 0xb5, 0xfc, 0xe0, 0x9f,
	0x79, 0x28, 0x9e, 0x32, 0x45, 0x11, 0x82, 0x62, 0x42, 0x63, 0x56, 0xcf, 0x1d, 0xe4, 0x0e, 0x2b,
	0xd8, 0x8c, 0xd1, 0x01, 0x54, 0x43, 0x26, 0xa7, 0x19, 0x4f, 0x15, 0x17, 0x49, 0x3d, 0x6f, 0x4c,
	0x9b, 0x10, 0xfa, 0x1c, 0x4a, 0xd3, 0x8c, 0x51, 0xc5, 0xc2, 0x7a, 0xe1, 0x20, 0x77, 0x58, 0x3d,
	0xde, 0x6f, 0xd8, 0x1d, 0x1b, 0xeb, 0x1d, 0x1b, 0xe3, 0xf5, 0x8e, 0x78, 0x4d, 0x45, 0x4f, 0x01,
	0xdc, 0x90, 0x4c, 0x56, 0xf5, 0xa2, 0x91, 0xad, 0x38, 0xa4, 0xb5, 0x42, 0x5f, 0xc3, 0x76, 0x44,
	0xa5, 0x22, 0xb1, 0x08, 0xf9, 0x25, 0x67, 0x61, 0xdd, 0xfb, 0x5e, 0xe9, 0x9a, 0x5e, 0x70, 0xea,
	0xf8, 0xe8, 0x10, 0xfc, 0x5b, 0x02, 0x7a, 0x97, 0x2d, 0xb3, 0xcb, 0xce, 0x26, 0xaf, 0xb5, 0x42,
	0xcf, 0xc1, 0x8b, 0xe8, 0x84, 0x45, 0xf5, 0xd2, 0x41, 0xe1, 0xb0, 0x7a, 0xbc, 0xd7, 0xb8, 0xe5,
	0xbe, 0x46, 0x5f, 0xdb, 0xb0, 0xa5, 0x04, 0x47, 0xe0, 0x99, 0x39, 0xf2, 0xa1, 0xf0, 0x27, 0xb6,
	0x72, 0x9e, 0xd2, 0x43, 0xb4, 0x07, 0xde, 0x6b, 0x1a, 0x2d, 0x98, 0x73, 0x91, 0x9d, 0x04, 0x5d,
	0xa8, 0xb6, 0x33, 0x7a, 0x15, 0x75, 0x12, 0xc5, 0xd5, 0x0a, 0xed, 0x40, 0x9e, 0x87, 0x6e, 0x55,
	0x9e, 0x87, 0xe8, 0x53, 0x28, 0xc6, 0x4c, 0x51, 0xb3, 0xa6, 0x7a, 0xfc, 0xe8, 0xce, 0xd6, 0xfa,
	0x51, 0xb0, 0x21, 0x04, 0xff, 0xca, 0x41, 0x71, 0xc4, 0x58, 0x78, 0x6f, 0x05, 0xf4, 0x13, 0xa8,
	0x30, 0x73, 0x08, 0xc2, 0xed, 0x43, 0x55, 0x70, 0xd9, 0x02, 0xbd, 0x10, 0x1d, 0x81, 0x27, 0xa7,
	0x22, 0x65, 0xe6, 0x21, 0xaa, 0xc7, 0x1f, 0xde, 0x91, 0x31, 0x57, 0x18, 0x69, 0x02, 0xb6, 0x3c,
	0xf4, 0x01, 0x6c, 0x7d, 0x27, 0x26, 0x5a, 0xca, 0x3b, 0x28, 0xe8, 0xeb, 0x7e, 0x27, 0x26, 0xbd,
	0x10, 0xed, 0x43, 0x39, 0xe4, 0x92, 0x4e, 0x22, 0x16, 0xd6, 0xd1, 0x41, 0xee, 0xb0, 0x8c, 0xaf,
	0xe7, 0xc1, 0x7f, 0x72, 0x50, 0x36, 0x42, 0xdf, 0x88, 0xc9, 0xfd, 0xaf, 0xf1, 0x31, 0x54, 0xe5,
	0x74, 0xce, 0xc2, 0x45, 0xc4, 0x6e, 0x2e, 0x02, 0x6b, 0xa8, 0x17, 0xa2, 0x2f, 0x60, 0x2b, 0xe2,
	0x31, 0x57, 0xd2, 0xdd, 0xe5, 0xe0, 0x6d, 0x77, 0xe9, 0x1b, 0x46, 0xdb, 0x64, 0x0d, 0x76, 0x7c,
	0xf4, 0x33, 0x78, 0x38, 0xd5, 0x46, 0x62, 0xb3, 0xc9, 0x5e, 0x4e, 0xcb, 0x6f, 0x1b, 0xd8, 0xb2,
	0xbf, 0xe7, 0x92, 0xff, 0xc8, 0xbb, 0x07, 0xb7, 0xec, 0xfb, 0xdf, 0xf3, 0x39, 0xec, 0x4e, 0x32,
	0x71, 0x25, 0x59, 0xb6, 0x71, 0x9c, 0x92, 0xd1, 0x79, 0xe8, 0x0c, 0xd7, 0x07, 0xfa, 0x04, 0xb6,
	0x53, 0x11, 0x71, 0xc5, 0x12, 0x26, 0xa5, 0xe6, 0x95, 0x0d, 0xaf, 0x76, 0x03, 0xf6, 0x42, 0xf4,
	0x2b, 0xf0, 0xd8, 0x52, 0x65, 0xb4, 0x5e, 0x71, 0x99, 0x74, 0x7b, 0xeb, 0x8e, 0xb6, 0x39, 0x87,
	0x58, 0x22, 0xfa, 0x0c, 0x76, 0x63, 0x9e, 0xf0, 0x78, 0x11, 0x93, 0x30, 0x91, 0x44, 0xa9, 0x88,
	0xc8, 0x3a, 0x1c, 0xe4, 0x0e, 0x3d, 0xbc, 0xe3, 0x0c, 0x27, 0x89, 0x1c, 0xab, 0x68, 0xa4, 0x5f,
	0x25, 0x64, 0xa9, 0x9a, 0x93, 0x4b, 0x9e, 0x49, 0x55, 0xdf, 0x33, 0x5e, 0x01, 0x03, 0x75, 0x35,
	0x12, 0xfc, 0x37, 0x07, 0x8f, 0x5c, 0x14, 0xd9, 0x97, 0x7a, 0x5f, 0xff, 0x7c, 0xaa, 0x1f, 0x4b,
	0x24, 0x84, 0x2d, 0xd3, 0x8c, 0x49, 0xa9, 0x6b, 0x93, 0x8d, 0x85, 0x1d, 0x0d, 0x77, 0xae, 0x51,
	0xf4, 0x25, 0xc0, 0x6b, 0x1a, 0xf1, 0x90, 0x5c, 0x66, 0x22, 0x76, 0x31, 0xf1, 0xae, 0x32, 0x52,
	0x31, 0xec, 0x6e, 0x26, 0x62, 0xf4, 0x02, 0xca, 0x76, 0xa9, 0x12, 0x3f, 0xa0, 0xfe, 0x94, 0x0c,
	0x77, 0x2c, 0x82, 0x5f, 0x02, 0xdc, 0x24, 0x8c, 0x09, 0xd8, 0x45, 0xa6, 0x48, 0x9a, 0xb1, 0x4b,
	0xbe, 0x74, 0x57, 0x05, 0x0d, 0x9d, 0x19, 0x24, 0x88, 0x60, 0xf7, 0x8d, 0x98, 0xd4, 0xd5, 0xc4,
	0x78, 0xcf, 0xf0, 0x3d, 0x6c, 0x27, 0xe8, 0xa7, 0xb0, 0x13, 0xd3, 0x25, 0x09, 0x17, 0x19, 0xd5,
	0xa5, 0x97, 0x48, 0xe3, 0xa7, 0x02, 0xae, 0xc5, 0x74, 0x79, 0xe2, 0xc0, 0x91, 0xce, 0x74, 0xcd,
	0x9a, 0xac, 0x14, 0x93, 0xc6, 0x29, 0x05, 0x5c, 0x8e, 0xe9, 0xb2, 0xa5, 0xe7, 0xc1, 0x5f, 0x3c,
	0xd8, 0x6e, 0x6d, 0xc6, 0xcf, 0xfd, 0x9f, 0xe0, 0x29, 0xc0, 0x42, 0xc7, 0x27, 0x9d, 0xb1, 0x44,
	0x39, 0xef, 0x57, 0x34, 0xd2, 0xd4, 0x00, 0x7a, 0x06, 0xb5, 0x2b, 0x9e, 0x84, 0xe2, 0x8a, 0x5c,
	0xf1, 0x50, 0xcd, 0x8d, 0xeb, 0x3d, 0x5c, 0xb5, 0xd8, 0xb7, 0x1a, 0xd2, 0x81, 0xeb, 0x28, 0x73,
	0xc6, 0x67, 0x73, 0x65, 0xbc, 0xec, 0x61, 0xb7, 0xee, 0x95, 0xc1, 0xd0, 0x11, 0xec, 0xa5, 0x74,
	0xc6, 0x48, 0x24, 0x68, 0x48, 0x74, 0xef, 0x12, 0x0b, 0x45, 0x62, 0x69, 0xaa, 0x79, 0x01, 0xef,
	0x6a, 0x5b, 0x5f, 0xd0, 0x70, 0x6c, 0x2d, 0xa7, 0x52, 0x87, 0x86, 0xed, 0x4e, 0x44, 0xb2, 0x88,
	0x4d, 0x95, 0xc8, 0x4c, 0x69, 0xaf, 0xe0, 0x1d, 0x0b, 0x8f, 0x1c, 0xaa, 0x1d, 0xe5, 0x88, 0x26,
	0x67, 0x34, 0xa5, 0x6c, 0x81, 0x5e, 0x88, 0xda, 0x50, 0x9a, 0x33, 0x1a, 0xb2, 0x4c, 0xd6, 0x7d,
	0xd3, 0x18, 0x3e, 0xbb, 0xe3, 0x89, 0x5b, 0x5e, 0x6c, 0xbc, 0xb2, 0xdc, 0x4e, 0xa2, 0xb2, 0x15,
	0x5e, 0xaf, 0x44, 0x04, 0x76, 0xdd, 0x0e, 0x29, 0xcd, 0x68, 0xcc, 0x94, 0x96, 0xdb, 0x35, 0x72,
	0xc7, 0xef, 0x94, 0x1b, 0x99, 0x55, 0x67, 0xd7, 0x8b, 0xac, 0xae, 0x2f, 0xef, 0xc0, 0xe8, 0x05,
	0x3c, 0x91, 0x11, 0x63, 0x29, 0xa1, 0x97, 0x8a, 0x65, 0x44, 0x3b, 0xc3, 0xf8, 0x29, 0x96, 0xa6,
	0x34, 0x15, 0xf0, 0x9e, 0x31, 0x37, 0xb5, 0xf5, 0xcc, 0x19, 0x4f, 0xe5, 0xfe, 0x57, 0x50, 0xdb,
	0x3c, 0xf0, 0x0f, 0x6d, 0x67, 0x5f, 0xe5, 0xbf, 0xc8, 0xed, 0xb7, 0xe1, 0x83, 0xb7, 0x9e, 0xee,
	0xc7, 0x88, 0x04, 0x7f, 0xf5, 0xc0, 0x3f, 0xbb, 0x2e, 0x4f, 0xef, 0x1b, 0x89, 0xbf, 0x83, 0xed,
	0x4c, 0x4c, 0x84, 0x92, 0x44, 0x97, 0xbc, 0xe9, 0xca, 0x04, 0xe3, 0xce, 0xf1, 0x2f, 0xee, 0xac,
	0xb8, 0xbb, 0x61, 0x03, 0x9b, 0x45, 0x67, 0x66, 0x0d, 0xae, 0x65, 0x1b, 0x33, 0xf4, 0x0d, 0x04,
	0xeb, 0xe2, 0xe7, 0xa4, 0x4d, 0x7a, 0xeb, 0xfe, 0xb9, 0x91, 0x7e, 0x55, 0x13, 0xaf, 0x1f, 0x39,
	0xa6, 0x95, 0xfb, 0xbd, 0xe3, 0xdd, 0x24, 0xe4, 0x27, 0xb0, 0x3d, 0x5d, 0x48, 0x25, 0xd6, 0x52,
	0xa6, 0x3e, 0x56, 0x70, 0xcd, 0x82, 0x76, 0x15, 0xfa, 0x1a, 0x9e, 0xc6, 0x3c, 0x31, 0x01, 0x4e,
	0x26, 0x4c, 0x5d, 0x31, 0x96, 0x90, 0x9b, 0xb8, 0x8f, 0x6d, 0x3b, 0x2b, 0xe0, 0x7a, 0xcc, 0x13,
	0x1d, 0xea, 0x2d, 0x4b, 0x39, 0x73, 0xd1, 0x7f, 0x6a, 0x05, 0xe8, 0xf2, 0x1d, 0x02, 0x9e, 0x13,
	0xa0, 0xcb, 0xb7, 0x0b, 0x3c, 0x83, 0x5a, 0xc8, 0x22, 0xba, 0x22, 0x97, 0xd4, 0x24, 0x8d, 0x4e,
	0xb0, 0xbc, 0xfe, 0xd6, 0x8b, 0xe8, 0xaa, 0x6b, 0x20, 0x5d, 0xcc, 0xf4, 0x1e, 0x19, 0x53, 0x19,
	0x67, 0xd2, 0xf4, 0x23, 0x0f, 0x43, 0x4c, 0x97, 0xd8, 0x22, 0xa8, 0x01, 0x8f, 0xb4, 0x71, 0x45,
	0xac, 0x92, 0x64, 0x53, 0x91, 0x84, 0xd2, 0x34, 0x24, 0x0f, 0xef, 0x1a, 0xd3, 0x89, 0xb6, 0x8c,
	0xac, 0x01, 0x7d, 0x09, 0x1f, 0xda, 0x9e, 0x3b, 0x17, 0x52, 0x91, 0x59, 0x26, 0x16, 0xe9, 0x4d,
	0xd6, 0x56, 0x4c, 0x4a, 0x3e, 0x36, 0x84, 0x57, 0x42, 0xaa, 0x97, 0xda, 0xbc, 0xce, 0xde, 0xa0,
	0x03, 0xb5, 0xcd, 0xf7, 0x43, 0x0f, 0xa1, 0x3a, 0x6c, 0x75, 0x2e, 0x08, 0x1e, 0xb6, 0x86, 0xe3,
	0x91, 0xff, 0x00, 0xed, 0xc2, 0x76, 0xef, 0xe5, 0x60, 0x88, 0x3b, 0x6b, 0x28, 0xa7, 0xa1, 0xf6,
	0xf9, 0x68, 0x3c, 0x3c, 0x5d, 0x43, 0xf9, 0xe0, 0x02, 0xaa, 0x1b, 0xbd, 0x4f, 0x3b, 0xc1, 0x74,
	0xbf, 0xa9, 0x22, 0x8a, 0x2d, 0x6d, 0x45, 0x2a, 0xe3, 0xaa, 0xc3, 0xc6, 0x6c, 0xa9, 0x6c, 0xeb,
	0xd1, 0x1f, 0xaa, 0x44, 0x26, 0x34, 0x95, 0x73, 0xa1, 0x8c, 0xab, 0xca, 0xba, 0xf5, 0x68, 0x78,
	0xe4, 0xd0, 0xe0, 0xcf, 0xd7, 0xa5, 0xd6, 0x26, 0xcc, 0xfd, 0x03, 0xfc, 0x31, 0x6c, 0xd9, 0xd4,
	0x77, 0x65, 0xd6, 0xcd, 0x4c, 0x09, 0xce, 0x22, 0x92, 0xb1, 0x19, 0x5b, 0xa6, 0xeb, 0xaf, 0xe8,
	0x45, 0x16, 0x61, 0x03, 0x04, 0xff, 0xce, 0xc1, 0x5e, 0xfb, 0x96, 0xf7, 0xde, 0x37, 0xd3, 0xba,
	0x50, 0xe6, 0x29, 0xc9, 0x68, 0x32, 0x63, 0xf5, 0x82, 0xa9, 0x63, 0x3f, 0x7f, 0xdb, 0xf7, 0xd5,
	0x9d, 0xfd, 0x1a, 0xbd, 0x14, 0xeb, 0x25, 0xb8, 0xc4, 0xed, 0x60, 0xff, 0x37, 0x50, 0x72, 0x18,
	0x7a, 0x02, 0x25, 0x9e, 0xda, 0xee, 0x6c, 0x0f, 0xb4, 0xc5, 0x53, 0xd3, 0x7e, 0x1f, 0x81, 0xc7,
	0x53, 0xdd, 0x7b, 0x6d, 0xf5, 0x28, 0xf2, 0x74, 0x2c, 0x82, 0xbf, 0xe7, 0xa1, 0xd2, 0x17, 0xb3,
	0x3e, 0x7b, 0xcd, 0x22, 0x89, 0x7e, 0x0b, 0x95, 0x48, 0xcc, 0x48, 0xa4, 0x67, 0xf5, 0x9c, 0x39,
	0xcf, 0xb3, 0xbb, 0xdf, 0xef, 0x6b, 0xf2, 0xf5, 0x08, 0x97, 0x23, 0x37, 0xda, 0xff, 0x03, 0x94,
	0xd7, 0xa8, 0xf6, 0x71, 0x24, 0x66, 0x33, 0x96, 0xad, 0x8f, 0x61, 0x67, 0xe8, 0x73, 0xf0, 0xac,
	0x7e, 0xde, 0x14, 0x95, 0x8f, 0xfe, 0xbf, 0xbe, 0x11, 0xb7, 0xe4, 0x60, 0x0e, 0x9e, 0x95, 0xdd,
	0x86, 0xca, 0xf9, 0xe0, 0xa4, 0xd3, 0xed, 0x0d, 0x3a, 0x27, 0xfe, 0x03, 0x54, 0x82, 0x42, 0xb3,
	0xdf, 0xf7, 0x73, 0xa8, 0x02, 0xde, 0x18, 0x37, 0xdb, 0x1d, 0x3f, 0xaf, 0x87, 0x27, 0x9d, 0xd6,
	0xf9, 0x4b, 0xbf, 0x80, 0xca, 0x50, 0xec, 0x0d, 0xba, 0x43, 0xbf, 0xa8, 0x47, 0xdf, 0x36, 0xf1,
	0xc0, 0xf7, 0xb4, 0xb9, 0x83, 0xf1, 0x10, 0xfb, 0x5b, 0x7a, 0xd8, 0x6d, 0x8e, 0x9b, 0x7d, 0xbf,
	0xa4, 0x85, 0x86, 0xdd, 0xae, 0x5f, 0x0e, 0xfe, 0x96, 0x83, 0x2a, 0x16, 0x11, 0x3b, 0xa5, 0x69,
	0xca, 0x93, 0x37, 0xdf, 0xf6, 0x31, 0x78, 0x2c, 0xa6, 0xdc, 0x9e, 0xbf, 0xf2, 0xea, 0x01, 0xb6,
	0x53, 0x8d, 0x9b, 0x7c, 0xb3, 0x21, 0xa5, 0x71, 0x33, 0xd5, 0xb1, 0x90, 0x89, 0x48, 0xff, 0x0a,
	0x14, 0x0e, 0x77, 0xde, 0x88, 0x05, 0xbd, 0x13, 0x36, 0x84, 0x96, 0x0f, 0x3b, 0x46, 0x89, 0x88,
	0xcc, 0x66, 0xee, 0xf3, 0x36, 0x14, 0xb5, 0x1d, 0xd5, 0xa0, 0xdc, 0x1c, 0x5c, 0x90, 0xf3, 0x51,
	0x07, 0xbb, 0x2b, 0x0f, 0x2e, 0xec, 0x95, 0x9b, 0x27, 0xa7, 0xbd, 0x81, 0x9f, 0x47, 0x55, 0x28,
	0xb5, 0xcf, 0x71, 0x73, 0x3c, 0xc4, 0x7e, 0x41, 0xd3, 0x71, 0xa7, 0x79, 0x32, 0x1c, 0xf4, 0x2f,
	0xfc, 0x62, 0xeb, 0x05, 0x3c, 0x49, 0x44, 0x23, 0x99, 0x34, 0x92, 0x84, 0xde, 0xde, 0xbc, 0x55,
	0xb5, 0xe1, 0x74, 0xa6, 0x3f, 0xbe, 0xfe, 0x78, 0xf3, 0x9b, 0x4b, 0x68, 0xca, 0x27, 0x5b, 0xe6,
	0x93, 0xec, 0xd7, 0xff, 0x0b, 0x00, 0x00, 0xff, 0xff, 0xe0, 0x44, 0xac, 0xed, 0x0c, 0x0f, 0x00,
	0x00,
}
